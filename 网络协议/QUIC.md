
## QUIC

TCP/UDP是通用协议，重在简单和通用，QUIC是一种针对浏览器和HTTP Server之间通讯进行优化了得专用协议，在一些问题领域做了很多取舍。

HTTP2 + SSL + TCP = HTTP2 + QUIC + UDP

### 优点：

- 1.多路复用，避免队头阻塞
- 2.减少RTT，更快速
- 3.改进了UDP的不可靠
- 4.加密技术更好
- 5.前向纠错

#### 1.多路复用，避免队头阻塞

##### 应用层的队头阻塞

`HTTP Pipeline管道技术`：就把 Connection 的默认值改成了Keep-Alive，同一个域名下的多个 HTTP 请求就可以复用同一个 TCP 连接。

但请求之间的数据传输是串行的，前面请求数据的传输会阻塞后面的请求。所有管道模型都难以避免的队头阻塞问题。
可以通过并发技术，一条TCP通道多条请求数据进行同步传输，但有并发数的限制。因此并发请求并非是直接解决了 HOC 的问题，而是尽可能减少 HOC 造成的影响

Pipeline 是为了减少不必要的 TCP 连接，但依然存在队头阻塞(HOC)的缺点，一种解决思路是利用并发连接减少某一个 HOC 的影响，另一个是共享(注意与复用的区别) TCP 连接，直接避免 HOC 问题的发生。

`SPDY`：采用多路复用（Multiplexing）技术，允许多个HTTP请求共享一个TCP连接。没有HOC问题，数据可以一起传输，但会导致数据略有冗余，每个资源的数据包都要带上标记。
给每个数据包做好标记，指明属于哪个HTTP请求。

这个协议还不成熟，是作为HTTP2的前身和试验品。

##### 传输层的队头阻塞

应用层协议队头阻塞的问题解决并不能阻止传输层TCP的丢包阻塞。队头阻塞不仅存在HTTP层，同时也存在TCP层。

TCP是可靠的，如果发生丢包或错包，则需要重传，会导致后面数据包的等待。窗口机制虽然提高了传输数据被干扰的能力，丢失几个ACK并不受影响，但包的丢失或错误会导致窗口无法后移，出现队头阻塞。

QUIC是基于UDP的，无序不可靠的，为QUIC支持多路复用提高了基础，但也要求QUIC自己保证数据的可靠性。

丢包重传成本太高，如果把要求降低成:“最多丢一个包，或者错一个包”，事情就简单多了，操作系统中有一种存储方式叫 RAID 5，采用的是异或运算加上数据冗余的方式来保证前向纠错(FEC: Forward Error Correcting)。

举个例子，假设有 5 个数据包要发送，我可以额外发送一个包(上面例子中的 T)，它的值是前五个包的异或结果。这样不管是前五个包中丢失了任何一个，或者某个包数据有错(可以当成丢包来处理)，都可以用另外四个包和这个冗余的包 T 进行异或运算，从而恢复出来。

对于某些非常重要的数据或者丢失两个包的情况可以采取重传。

#### 2.减少RTT，更快速

HTTPS连接需要建立三次TCP握手，四次SSL/TLS握手验证。

##### SSL握手优化

SSL四次握手需要2个RTT。

- 客户端发送第一个握手，包含一个随机数，以及对协议的支持情况(版本、加密方法、压缩方法等)
- 服务器返回证书，以及服务端生成随机数
- 客户端校验证书，生成一个新的随机数，用证书中的公钥加密后发给服务端
- 服务端确认消息，双方根据上述三个随机数生成后续会话的公钥

SSL握手优化方案： 只需要1个RTT。

一个常用的方案是采用 Session Ticket，实现起来很容易: 一旦 SSL 会话建立起来，服务端把会话的基本信息，比如对称秘钥、加密方法等信息加密后发给客户端，客户端可以缓存下来这个 Session Ticket。需要恢复 SSL 会话时直接把它发回给服务端校验即可，这样可以在 SSL 层减少一个 RTT。

##### TCP握手优化
 
TCP快速打开：TFO (TCP Fast Open)，这是对 TCP 的拓展，不仅可以在发送 SYN 时携带数据，还可以保证安全性。

TFO 设计了一个 cookie，它在第一次握手时由 server 生成，cookie 主要是用来标识客户端的身份，以及保存上次会话的配置信息。因此在后续重新建立 TCP 连接时，客户端会携带 SYN + Cookie + 请求数据，然后不等 ACK 返回就直接开始发送数据。

为了安全起见，服务端为每个端口记录了一个值 PendingFastOpenRequests，用来表示有多少请求利用了 TFO，如果超过预设上限就不再接受。


##### SSL和TCP优化总结：

- 1.TFO 设计的 cookie 思想和 SSL 恢复握手时的 Session Ticket 很像，都是由服务端生成一段 cookie 交给客户端保存，从而避免后续的握手，有利于快速恢复。

- 2.第一次请求绝对不会触发 TFO，因为服务器会在接收到 SYN 请求后把 cookie 和 ACK 一起返回。后续客户端如果要重新连接，才有可能使用这个 cookie 进行 TFO

- 3.TFO 并不考虑在 TCP 层过滤重复请求，以前也有类似的提案想要做过滤，但因为无法保证安全性而被拒绝。所以 TFO 仅仅是避免了泛洪攻击(类似于 backlog)，但客户端接收到的，和 SYN 包一起发来的数据，依然有可能重复。不过也只有可能是 SYN 数据重复，所以 TFO 并不处理这种情况，要求服务端程序自行解决。这也就是说，不仅仅要操作系统的支持，更要求应用程序(比如 MySQL) 也支持 TFO。

实质都是缓存之前建立握手成功的信息，免去再次发起连接的握手步骤。

##### 0-RTT

TFO 使得 TCP 协议有可能变成 0-RTT，核心思想和 Session Ticket 的概念类似: 将当前会话的上下文缓存在客户端。如果以后需要恢复对话，只需要将缓存发给服务器校验，而不必花费一个 RTT 去等待

使用 QUIC 协议，我们甚至可以更进一步，将 Session Ticket 也放到 TFO 中一起发送，这样就实现了 0-RTT 的对话恢复

#### 3.改进了UDP的不可靠

UDP 协议不保证数据可达性，但这也是 UDP 的优点所在，它天然支持 0-RTT 的通信，所以一个比较新颖激进的想法就冒出来了:
采用 UDP 作为底层协议，在 UDP 之上实现数据可达性。

#### 4.加密技术更好
总体性能上比TLS好很多，也具有各种攻击防御策略。

#### 5.前向纠错

QUIC和TCP一个主要的核心区别就是：TCP采用 重传 机制，而QUIC采用 纠错 机制。

    如果发生丢包的话，TCP首先需要一个等待延时来判断发生了丢包，然后再启动重传机制，在此期间会对连接造成一定的阻塞（并且TCP窗口是缓慢增大的，Web这种突发性快速连接情况下窗口会相对较小），从而影响传输时间。

    而QUIC采用了一种脑洞极大的前向纠错（FEC）方案，类似于RAID5，将N个包的校验和（异或）建立一个单独的数据包发送，这样如果在这N个包中丢了一个包可以直接恢复出来，完全不需要重传，有利于保证高速性，N可以根据网络状况动态调整。

### 问题解答：

##### 1.QUIC 协议有哪些优点，如何实现 0-RTT？

QUIC 协议在传输层就支持多路复用，避免了队头阻塞问题。
QUIC 协议基于 UDP，更自由更高效
QUIC 协议借鉴了 TFO 的思想，支持会话上下文缓存，方便恢复，具备实现 0-RTT 的可能

##### 2.传统的 HTTP2 + SSL + TCP 协议栈有哪些缺点？

SSL 的会话恢复依然需要一个 RTT，而且难以合并到 TCP 层
TCP 的滑动窗口存在队头阻塞问题
TCP 的重传纠错会浪费一个 RTT

##### 3.为什么 Google 要另起炉灶，基于 UDP 去做？

TCP 由操作系统实现，很难更新
UDP 非常高效，几乎没有性能负担
将 QUIC 嵌入到 Chrome 中可以方便后续的升级迭代


