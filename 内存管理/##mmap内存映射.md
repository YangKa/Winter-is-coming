##mmap内存映射

###栗子：
使用NSData的dataWithContentsOfFile:方法加载大数据资源是，可能会直接将内存耗尽。
改用使用：
	+ (id)dataWithContentsOfFile:(NSString *)path options:(NSDataReadingOptions)readOptionsMask error:(NSError **)errorPtr;
其中的NSDataReadingOptions可以附加一个参数：NSDataReadingMappedIfSafe。使用这个参数系统不会将整个文件全部读取到内存，而是将文件映射到进程的地址空间中，这样做并不会占用实际内存。


- 文件映射指将文件内容映射到进程的虚拟地址空间，并没有在内存中为文件分配物理空间，只是让内存地址指向文件的磁盘地址。对文件的内存读写，实际上是对文件的磁盘读写。（竟然和SSD如此相似，😓）

###映射原理

- 1.进程启动映射的实现过程，并在虚拟空间中为映射创建虚拟映射区域

- 2.调用内核控件的系统调用函数mmap，实现文件物理地址和进程虚拟地址的一一映射关系

- 3.进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝

   
note：修改的数据不会立即更新会文件中，有一段时间的延迟，可以调用msync()来强制同步，这样就能立即把内存页缓存中修改的数据协会磁盘中。


####和常规文件操作的区别

- 对内存和磁盘数据的读写采用了页缓存机制。内存和磁盘都有一个缓存页表，以页的形式存放着最近访问的临时数据，提高访问数据的效率。

使用常规访问：
- 访问内存中的数据，会查询内存缓存页表，查到查询地址没在页表中，产生缺页异常。这时会发起调页请求，将数据从内存复制到页缓存。之后再发起读页面过程，进而将页缓存中的数据发送给用户进程。
- 访问磁盘中的数据，需要先将数据从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以需要将页缓存数据再次拷贝到内存对应的用户空间中。这样就经历了两次拷贝。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次缓存。

使用mmap
- 创建新的虚拟内存区域和建立磁盘地址和虚拟内存地址区域映射，并没有文件拷贝操作。之后再内存中访问磁盘数据发生缺页操作，可以通过建立的映射关系，只使用一次数据拷贝，就将磁盘数据传入内存的用户空间中，供进程使用。

使用mmap减少了数据拷贝的次数，提高了数据读写的操作效率。

####优点

- 1、对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。

- 2、实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。

- 3、提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。

     同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。

- 4、可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。


####使用细节
- 1.映射的是磁盘地址，即使文件关闭，映射依然存在。
- 2.用于进程间通信的有效地址空间不完全受限于被映射文件的大小，因为是按页映射。
- 3.内核可以跟踪被内存映射的底层对象的大小，进程可以合法的访问在当前文件大小以内又在内存映射区的那些字节。
- 4.mmap映射区域必须是物理页大小（page_size）的整数倍。访问页中超过文件地址的部分会返回一个SIGSECV错误。

####参考

- ![认真分析mmap：是什么 为什么 怎么用](http://www.cnblogs.com/huxiao-tee/p/4660352.html)