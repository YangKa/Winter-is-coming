## 提高野指针的Crash率

Crash最多的原因通常有两种，一种是多线程，一种是野指针。
这两种Crash都带随机性，而且这两种Crash有相当一部分都很难区分，甚至大量的Crash只有系统栈，如果不能根据日志重现，几乎是无解，让人非常蛋疼。

野指针是指指向一个已删除的对象或未申请访问受限内存区域的指针。Obj-C的野指针最常见的一种栈是objc_msgSend。

#### 野指针的难测性体现在随机性：
- 1.跑不进出错的逻辑，执行不到出错的代码，这种可以提高测试场景覆盖度来解决。
- 2.跑进了有问题的逻辑，但是野指针指向的地址并不一定会导致Crash，有点运气成分。


### 提高野指针访问crash概率：

1.主动在对象释放后在内存上填上不可访问的数据，让访问该内存时必然crash。

	- 通过开启scheme中Diagnostics的Malloc Scribble。
	- 通过重写对象释放的接口，手动进行复写不可访问数据操作。
		通过选择NSObject的dealloc、runtime的object_dispose、C的free中的free，重写它可以顺带解决一部分C的野指针问题。
		使用现成fishhook库进行free的替换。
		
		void safe_free(void* p){
			size_t memSiziee = malloc_size(p)
			memset(p, 0x55, memSizee);
			orig_free(p);
			return;
		}	
	如果释放的内存恰好被其它能响应的对象覆写，也不会crash。
	
2.当free被调用的时候我们不真的调用free，而是自己保留着内存，这样系统不知道这片内存已经不需要用了，自然就不会被再次写上别的数据。

	为了防止系统内存过快耗尽，还需要额外多做几件事：
	1. 自己保留的内存大于一定值的时候就释放一部分，防止被系统杀死。
	2. 系统内存警告的时候，也要释放一部分内存。

	对于报的异常，有些crash并不能很好定位分析。，这样获取的信息就会不全。
	
3.不释放内存，直接修改原有对象的isa指针指向新的类，然后crash时调用新的类中方法。

	- 需要自己写一个类，用它的isa来替换已经释放的对象的isa。
	- 类覆盖之后，之前调用的sel就换成了调用我们自己的类的某个sel。这样，只要我们指定的类也实现这个方法，就可以执行我们需要执行的代码，然后在里面获取我们需要的信息。
	- 当然，我们无法预料野指针对象会在调用哪个函数时发生Crash，好在我们可以利用runtime的重定向特性了转到我们自己的代码里面去。