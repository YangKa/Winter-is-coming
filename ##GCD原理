##GCD原理

```
	GCD是提供了功能强大的任务和队列控制功能，相比于NSOperation更加底层，虽然现象苹果极力的推荐使用NSOperation来解决多线程问题, 但是,就目前市场上大部分企业的iOS开发团队而言, GCD仍然还是大头, NSOperation也只会逐步的来替代GCD, 但在多线程处理的时候,如果不注意也会导致一些问题, 比如死锁。
```

串行与并行针对的是队列，而同步与异步，针对的则是线程。

1.dispatch_async 函数如何实现，分发到主队列和全局队列有什么区别，一定会新建线程执行任务么？


2.dispatch_sync 函数如何实现，为什么说 GCD 死锁是队列导致的而不是线程，死锁不是操作系统的概念么？


3.信号量是如何实现的，有哪些使用场景？


4.dispatch_group 的等待与通知、dispatch_once 如何实现？


5.dispatch_source 用来做定时器如何实现，有什么优点和用途？


6.dispatch_suspend 和 dispatch_resume 如何实现，队列的的暂停和计时器的暂停有区别么？


7.队列和线程的关系
	GCD是面向队列的，我们选择API向队列添加任务block。每个队列都管理着一个线程池，根据系统负载情况增减线程并发数，执行block。

	- 并行队列，会权衡当前系统负载，去同时并发几条线程去执行Block。
	- 串行队列中，始终只在一条线程中执行Block。

	- 主队列是串行队列，队列中只有一条主线程。

	sync、async
	- 往主队列提交block，无论是sync、async，都在主线程中执行。
	- 往非主线程中提交，如果是sync，会在当前提交的Block的线程中执行。如果是async，则在分线程中执行。

8.GCD的死锁
	如果sync提交一个block到一个串行队列，而提交block这个动作所在的线程，也是在这个当前队列中，就会引起死锁。

9.API的异同和作用场景
	dispatch_async：不阻塞当前线程，添加到执行队列，根据队列情况执行。
	dispatch_barrier_async: 会阻塞当前提交block的线程，会阻塞并行队列，保证它前面的任务优先于自己执行，后面的任务都晚于自身执行。（读操作同步并行，写操作栏栅串行）
	dispatch_barrier_sync：呈上起下，和dispatch_barrier_async一样，唯一不同是会阻塞当前提交block的线程。
	dispatch_sync: 会阻塞当前提交block的线程，但不能阻塞并行队列

	- 同步和异步的使用，可以在不加锁的情况下，保证数据读写的线程安全。真正的加上是在GCD底层的信号量机制中体现。

注意点：
1.创建线程会有内存开销和时间开销，线程上下文的切换也需要开销。并发编程下的线程过多时性能反而会下降。
2.资源共享会导致线程竞争和锁。多个线程对共有资源进行写操作时，会产生数据错误，造成不可预料的结果。加锁可以放在线程竞争，但也容易导致死锁。过多的锁也会有一定的开销。
3.队列优先级越过锁
3.并发导致资源竞争
