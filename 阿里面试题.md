1.dSYM你是如何分析的？

	dSYM文件是iOS编译后保存的`16进制函数地址映射信息`的文件，每次应用程序build后都会生成对应的xxx.app, xxx.app.dSYM文件。

	1.通过dwarfdump --uuid 找到xx.app、xx.app.dSYM文件的uuid，同时在xx.crash日志的Binary Images：中的第一行尖括号内找到uuid。然后将三个文件置于同一文件夹下。
	2.通过symbolicatecrash分析crash文件，将crash文件中的16进制地址转换成可读的函数地址。
	命令格式如下：
	[symbolicatecrash路径] [crash日志路径]  [dSYM文件路] > [outputFileName].crash

2.多线程有哪几种？你更倾向于哪一种？

	NSThread
	NSOperation
	GCD
	
3.单例弊端？

	优点：
	1.全局对象，多处可用
	2.对象唯一，不用重复创建
	3.对象单一性，保证了属性和功能入口的唯一性
	缺点：
	1.使用的不确定性导致无法销毁
	2.占用资源、KVO和通知对象无法移除
	3.不利于统一管理，过于分散
	
4.如何把异步线程转换成同步任务进行单元测试？

	通过dispatch_group和dispatch_group_notify
	
5.介绍下APP启动的完成过程？

	T1-点击APP图标到启动Main函数期间：
		1.初始化控件并创建进程
        	2.解析加载mach-o可执行文件
        	3.加载系统动态链接库
     T2-启动Main函数期间(具体指Application:didFinishLaunchingWithOptions:执行完时间)：
		1.调用Main（）函数，创建UIApplication单例
        	2.建立UIApplication Delegate委托对象。
        	3.加载Info。plist配置文件
        	4.开启全局runloop
        	5.创建keyWindow承载View层的显示
        	6.创建rootViewController进行显示

6.APP启动过慢的可能因素有哪些？

	资源加载到系统库时间过长：
		1.可执行文件过大，加载时间过长
        	2.内嵌库太多，加载耗时
	在页面启动前做了太多耗时操作：
		1.willFinishLaunchingWithOptions:或didFinishLaunchingWithOptions：中存在耗时任务
        	2.页面渲染慢
	
	启动速度优化：
		1.内嵌的dylib尽可能的少，或者合起来
        	2.不要在+load和+initialize中做耗时操作
        	3.不要使用xib，直接用代码加载首页视图
         4.release版本不要又NSLog输出
		5.启动时的网络尽可能做异步操作
        	6.Rebase/Binding减少__DATA中需要修正的指针。 对于oc来说减少 class, selector, category 这些元数据的数量，对与c++来说，减少虚函数数量。swift结构体需要修正的比较少。
            
7.0x8badf00d表示什么？

	应用程序启动崩溃，Exception Codes:0x8badfood
	原因：程序启动时间不能超过5-6秒
	解决：UIApplicationDelegate中不要有耗时操作，或者把耗时操作异步处理。

8.怎么防止反编译？

	混淆和加壳

10.说说你了解的第三方原理或底层知识？

	三方库：
		SDWebImage
		AFNetworking
		KVOController
		TZImagePickerController
		MJRefresh
		FMDB
		MJExtension
	
	底层知识：
		runtime
		消息转发

1.介绍下内存的几大区域？

	堆区： ARC
	栈区：自动释放
	全局区：全局变量或静态变量
	
2.你是如何组件化解耦的？

	protocol去类型化
	中间件mediator
	路由
	
3.runtime如何通过selector找到对应的IMP地址？

	正常查找：
	1.查找obj的方法缓存列表
	2.查找obj的方法列表
	3.通过继承链，将消息转发给夫类进行查找
	4.一直查到NSObject根类查找不到则进行消息转发
	
	消息转发：
	5.resolveInstanceMethod/resolveClassMethod，尝试给类addMethod来进行响应
	6.forwardTargetForSelector:尝试修改selector的target进行响应
	7.forwardInvocation:修改Invocation，修改方法签名和响应者
	8.以上任意一步成功则重新进行1-4步,失败则调用doesNotRecongnizeSelector:

4.runloop内部实现逻辑？

5.你理解的多线程？

6.GCD执行原理？

7.怎么防止别人动态在你程序生成代码？

8.YYAsyncLayer如何异步绘制？

	YYSentinel：线程安全的计数器
	YYTransaction:注册runloop调用
	YYAsyncLayer:异步绘制CALayer子类
	
	YYAsyncLayer继承CALayer，通过CoreGraphic相关方法，在子线程中绘制内容Context，绘制完成后，会到主线程对layer.contents进行直接显示。
	控制渲染线程的数量以及通过原子技术YYSentinel控制取消异步渲染的内容。
	通过delegate回调，使得不同的delegate对象在block中绘制需要的内容。
	
	流程：
	1.通过YYTransaction在主RunLoop中注册一个observer，监听的事件与Core Animation一样，但优先级比CA低。当runloop进入休眠、CA处理完事件后，YYTransaction就会执行该loop内提交的所有任务。
	2.通过重写display方法，向delegate（也就是UIView）请求一个异步绘制的任务，并且在子线程中绘制Core Graphic对象，最后在主线程中设置layer.contents内容。
	3.异步绘制时，Layer会传递一个BOOL(^isCancelled)()的block，通过检查计数器的值来随时判断任务是否已经被取消。
	
	对比：
	Facebook开源的AsyncDisplayKit

9.优化你是从哪几方面着手？

	其它：
		代码结构优化
        	模块的独立性
		API包大小
	性能优化：
		启动速度
        	页面的流程性
      	交互响应速度
      	耗电
      	异常情况下的稳定性
      
  ------------------------------------------------------------------------
  ios编译
  预处理->  语法和语义分析-> 生成代码和优化 -> 汇编 -> 链接
  
  Clang作为编译前端， LLVM作为编译后端
  
  Clang的任务：预处理、词法分析、语法分析、语义分析、静态分析、生成中间代码
  预处理：以#开头的代码预处理，包括引入的头文件和自定义宏
  词法分析: 每一个.m源文件的声明和定义从string转化为特殊的标记流
  语法分析：将标记流解析成一颗抽象语法树
  静态分析：包含类型检查和其他检查
  中间代码生成：生成LLVM代码
  
  LLVM的任务：优化代码并产生汇编代码
  汇编器：将可读的汇编代码转换为机器代码，最终创建一个目标对象.o文件
  链接器的任务：把目标文件和库相连，最终输出可运行文件：a.out
  
  LLVM的任务：
