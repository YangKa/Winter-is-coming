1.多线程有哪几种？你更倾向于哪一种？

	NSThread
	NSOperation
	GCD
	
3.怎么防止反编译？

	混淆和加壳

4.说说你了解的第三方原理或底层知识？

	缓存：
		SDWebImage
    		YYCache
        	AFNetworking 的图片缓存管理
  	网络：
		AFNetworking
    	KVO：
		KVOController
    	图片库：
		TZImagePickerController
    	刷新：
		MJRefresh
    	模型格式化：
        	MJExtension
    	数据库：
		FMDB/CoreData
    	动画：
        	pop
	异步绘制：
		YYAsyncLayer
        	AsyncDisplayKit
    	socket：
        	SocketRocket
    	布局：
        Masonry
        TYAttributedLabel
    	键盘：
        IQKeyboardManager
	底层知识：
		runtime
		消息转发

5.介绍下内存的几大区域？

	堆区： ARC
	栈区：自动释放
	全局区：全局变量或静态变量
	
6.你是如何组件化解耦的？

	protocol去类型化
	中间件mediator
	路由
	
10.怎么防止别人动态在你程序生成代码？
        
------------------------------------------------------------------------

1.dSYM你是如何分析的？

    dSYM文件是iOS编译后保存的`16进制函数地址映射信息`的文件，每次应用程序build后都会生成对应的xxx.app, xxx.app.dSYM文件。

    1.通过dwarfdump --uuid 找到xx.app、xx.app.dSYM文件的uuid，同时在xx.crash日志的Binary Images：中的第一行尖括号内找到uuid。然后将三个文件置于同一文件夹下。
    2.通过symbolicatecrash分析crash文件，将crash文件中的16进制地址转换成可读的函数地址。
    命令格式如下：
    [symbolicatecrash路径] [crash日志路径]  [dSYM文件路] > [outputFileName].crash

2.单例弊端？

    优点：
    1.全局对象，多处可用
    2.对象唯一，不用重复创建
    3.对象单一性，保证了属性和功能入口的唯一性
    缺点：
    1.使用的不确定性导致无法销毁
    2.占用资源、KVO和通知对象无法移除
    3.不利于统一管理，过于分散

3.介绍下APP启动的完成过程？

    T1-点击APP图标到启动Main函数期间：
    1.初始化控件并创建进程
    2.解析加载mach-o可执行文件
    3.加载系统动态链接库
    
    T2-启动Main函数期间(具体指Application:didFinishLaunchingWithOptions:执行完时间)：
    1.调用Main（）函数，创建UIApplication单例
    2.建立UIApplication Delegate委托对象。
    3.加载Info。plist配置文件
    4.开启全局runloop
    5.创建keyWindow承载View层的显示
    6.创建rootViewController进行显示

4.APP启动过慢的可能因素有哪些？

    资源加载到系统库时间过长：
    1.可执行文件过大，加载时间过长
    2.内嵌库太多，加载耗时
    在页面启动前做了太多耗时操作：
    1.willFinishLaunchingWithOptions:或didFinishLaunchingWithOptions：中存在耗时任务
    2.页面渲染慢

    启动速度优化：
    1.内嵌的dylib尽可能的少，或者合起来
    2.不要在+load和+initialize中做耗时操作
    3.不要使用xib，直接用代码加载首页视图
    4.release版本不要又NSLog输出
    5.启动时的网络尽可能做异步操作
    6.Rebase/Binding减少__DATA中需要修正的指针。 对于oc来说减少 class, selector, category 这些元数据的数量，对与c++来说，减少虚函数数量。swift结构体需要修正的比较少。

5.0x8badf00d表示什么？

    应用程序启动崩溃，Exception Codes:0x8badfood
    原因：程序启动时间不能超过5-6秒
    解决：UIApplicationDelegate中不要有耗时操作，或者把耗时操作异步处理。

6.runtime如何通过selector找到对应的IMP地址？

    正常查找：
    1.查找obj的方法缓存列表
    2.查找obj的方法列表
    3.通过继承链，将消息转发给夫类进行查找
    4.一直查到NSObject根类查找不到则进行消息转发

    消息转发：
    5.resolveInstanceMethod/resolveClassMethod，尝试给类addMethod来进行响应
    6.forwardTargetForSelector:尝试修改selector的target进行响应
    7.forwardInvocation:修改Invocation，修改方法签名和响应者
    8.以上任意一步成功则重新进行1-4步,失败则调用doesNotRecongnizeSelector:

7.YYAsyncLayer如何异步绘制？

    YYSentinel：线程安全的计数器
    YYTransaction:注册runloop调用
    YYAsyncLayer:异步绘制CALayer子类

    YYAsyncLayer继承CALayer，通过CoreGraphic相关方法，在子线程中绘制内容Context，绘制完成后，会到主线程对layer.contents进行直接显示。
    控制渲染线程的数量以及通过原子技术YYSentinel控制取消异步渲染的内容。
    通过delegate回调，使得不同的delegate对象在block中绘制需要的内容。

    流程：
    1.通过YYTransaction在主RunLoop中注册一个observer，监听的事件与Core Animation一样，但优先级比CA低。当runloop进入休眠、CA处理完事件后，YYTransaction就会执行该loop内提交的所有任务。
    2.通过重写display方法，向delegate（也就是UIView）请求一个异步绘制的任务，并且在子线程中绘制Core Graphic对象，最后在主线程中设置layer.contents内容。
    3.异步绘制时，Layer会传递一个BOOL(^isCancelled)()的block，通过检查计数器的值来随时判断任务是否已经被取消。

    对比：
    Facebook开源的AsyncDisplayKit
    
8.你理解的多线程？

    多线程就是为了更好的利用现有资源做更多的事。给不同的线程分派不同的任务，例如主线程负责UI事件的响应、界面的绘制等，后台线程做一些并行不影响现有操作的任务。多线程虽然能提高多任务处理的效率，但使用不当对于共有资源却会产生竞争，甚至是死锁。
    多线程的使用方式主要的有NSThread、NSOperation、GCD三种，主流的是NSOperation和GCD。
    NSOperation和GCD可以说是面向队列的，多线程都由各自的队列根据系统资源情况去管理。
    队列的任务是多项的，线程的任务是单一的，每个线程内部都有一个runLoop循环处理任务，一个autoreleasePool线程池来销毁当前线程的持有对象。
    
9.runloop内部实现逻辑？
    
    启动runLoop后会开启一个循环，不断接受事件，如果事件不是结束命令则处理该事件，然后继续接受下一个事件进行判断处理。
    大致流程如下：
    startRunLoop()
    while (message != 退出){
    handle( message)
    message = getNextEvent()
    }
    
    这些事件都是被添加到runloop的不同mode中，只有和当前mode相匹配的事件才会得到处理。例如，scrollView滚动会切换当前线程的runloop进入UITrackingRunLoopMode下，导致注册到defaultMode下的Timer定时器被停止。
    
10.GCD执行原理？
    
    每个队列维护这一个任务队列和一个线程池，向队列提交的block任务按FIFO添加在任务列队尾部。队列根据系统资源负载情况增减线程池中的线程数，根据任务和队列的类型进行处理，并采用信号量机制和原子操作进行线程管理。
    
11.如何把异步线程转换成同步任务进行单元测试？
    
    1.通过dispatch_group和dispatch_group_notify
    2.通过信号量机制
    3.通过dispatch_group_enter/dispatch_group_leave
    
12.优化你是从哪几方面着手？
    
    用户体验：
        页面的流程性
        界面美观
        操作遍历性
    性能体验：
        APP启动速度
        交互响应速度
        耗电
    其它：
        代码结构优化
        架构优化
        API包大小

------------------------------------------------------------------------

  ios编译
  预处理->  语法和语义分析-> 生成代码和优化 -> 汇编 -> 链接
  
  Clang作为编译前端， LLVM作为编译后端
  
  Clang的任务：预处理、词法分析、语法分析、语义分析、静态分析、生成中间代码
  预处理：以#开头的代码预处理，包括引入的头文件和自定义宏
  词法分析: 每一个.m源文件的声明和定义从string转化为特殊的标记流
  语法分析：将标记流解析成一颗抽象语法树
  静态分析：包含类型检查和其他检查
  中间代码生成：生成LLVM代码
  
  LLVM的任务：优化代码并产生汇编代码
  汇编器：将可读的汇编代码转换为机器代码，最终创建一个目标对象.o文件
  链接器的任务：把目标文件和库相连，最终输出可运行文件：a.out
  
  LLVM的任务：
