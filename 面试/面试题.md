##面试题

#####1. 请说明并比较以下关键词：__weak，__block

	__weak与weak基本相同。前者用于修饰变量（variable），后者用于修饰属性（property）。__weak 主要用于防止block中的循环引用。
	
	__block也用于修饰变量。它是引用修饰，所以其修饰的值是动态变化的，即可以被重新赋值的。__block用于修饰某些block内部将要修改的外部变量。
	
	__weak和__block的使用场景几乎与block息息相关。而所谓block，就是Objective-C对于闭包的实现。闭包就是没有名字的函数，或者理解为指向函数的指针。

#####2.NSRunLoop mode种类：

	• Default（NSDefaultRunLoopMode）：默认，一般情况下使用；

	• Connection（NSConnectionReplyMode）：一般系统用来处理NSConnection相关事件，开发者一般用不到；

	• Modal（NSModalPanelRunLoopMode）：处理modal panels事件；

	• Event Tracking（NSEventTrackingRunLoopMode）：用于处理拖拽和用户交互的模式。

	• Common（NSRunloopCommonModes）：模式合集。默认包括Default，Modal，Event Tracking三大模式，可以处理几乎所有事件。

#####3.NSTimer不准的解决方案：
	1.将timer加入到NSRunloopCommonModes中
	2.将timer放到另一个线程中，然后开启另一个线程的runloop


###-----Swift-------

#####1. 类（class）和结构体（struct）有什么区别？
	类是引用类型，结构体是值类型。值类型在传递和赋值时将进行复制，而引用类型则只会使用引用对象的一个"指向"。所以他们两者之间的区别就是两个类型的区别。

	class有这几个功能struct没有的：
	
		class可以继承，这样子类可以使用父类的特性和方法
		类型转换可以在runtime的时候检查和解释一个实例的类型
		可以用deinit来释放资源
		一个类可以被多次引用
		
	struct也有这样几个优势：
	
		结构较小，适用于复制操作，相比于一个class的实例被多次引用更加安全。
		无须担心内存memory leak或者多线程冲突问题

#####2.Swift 是面向对象还是函数式的编程语言?
	
	Swift 既是面向对象的，又是函数式的编程语言。

	说 Swift 是面向对象的语言，是因为 Swift 支持类的封装、继承、和多态，从这点上来看与 Java 这类纯面向对象的语言几乎毫无差别。

	说 Swift 是函数式编程语言，是因为 Swift 支持 map, reduce, filter, flatmap 这类去除中间状态、数学函数式的方法，更加强调运算结果而不是中间过程。

#####3.请说明并比较以下关键词：Open, Public, Internal, File-private, Private

	Swift 有五个级别的访问控制权限，从高到底依次为比如 Open, Public, Internal, File-private, Private。

	他们遵循的基本原则是：高级别的变量不允许被定义为低级别变量的成员变量。比如一个 private 的 class 中不能含有 public 的 String。反之，低级别的变量却可以定义在高级别的变量中。比如 public 的 class 中可以含有 private 的 Int。

	Open 具备最高的访问权限。其修饰的类和方法可以在任意 Module 中被访问和重写；它是 Swift 3 中新添加的访问权限。
	
	Public 的权限仅次于 Open。与 Open 唯一的区别在于它修饰的对象可以在任意 Module 中被访问，但不能重写。
	
	Internal 是默认的权限。它表示只能在当前定义的 Module 中访问和重写，它可以被一个 Module 中的多个文件访问，但不可以被其他的 Module 中被访问。
	
	File-private 也是 Swift 3 新添加的权限。其被修饰的对象只能在当前文件中被使用。例如它可以被一个文件中的 class，extension，struct 共同使用。
	
	Private 是最低的访问权限。它的对象只能在定义的作用域内使用。离开了这个作用域，即使是同一个文件中的其他作用域，也无法访问。

#####4.说说Swift为什么将String，Array，Dictionary设计成值类型？

	要解答这个问题，就要和Objective-C中相同的数据结构设计进行比较。Objective-C中，字符串，数组，字典，皆被设计为引用类型。

	值类型相比引用类型，最大的优势在于内存使用的高效。值类型在栈上操作，引用类型在堆上操作。栈上的操作仅仅是单个指针的上下移动，而堆上的操作则牵涉到合并、移位、重新链接等。也就是说Swift这样设计，大幅减少了堆上的内存分配和回收的次数。同时copy-on-write又将值传递和复制的开销降到了最低。
	
	String，Array，Dictionary设计成值类型，也是为了线程安全考虑。通过Swift的let设置，使得这些数据达到了真正意义上的“不变”，它也从根本上解决了多线程中内存访问和操作顺序的问题。
	
	设计成值类型还可以提升API的灵活度。例如通过实现Collection这样的协议，我们可以遍历String，使得整个开发更加灵活高效。

#####5. 请说明并比较以下关键词：strong, weak, unowned

	Swift 的内存管理机制与 Objective-C一样为 ARC（Automatic Reference Counting）。它的基本原理是，一个对象在没有任何强引用指向它时，其占用的内存会被回收。反之，只要有任何一个强引用指向该对象，它就会一直存在于内存中。

	strong 代表着强引用，是默认属性。当一个对象被声明为 strong 时，就表示父层级对该对象有一个强引用的指向。此时该对象的引用计数会增加1。
	
	weak 代表着弱引用。当对象被声明为 weak 时，父层级对此对象没有指向，该对象的引用计数不会增加1。它在对象释放后弱引用也随即消失。继续访问该对象，程序会得到 nil，不亏崩溃
	unowned 与弱引用本质上一样。唯一不同的是，对象在释放后，依然有一个无效的引用指向对象，它不是 Optional 也不指向 nil。如果继续访问该对象，程序就会崩溃。
	加分回答：

	weak 和 unowned 的引入是为了解决由 strong 带来的循环引用问题。简单来说，就是当两个对象互相有一个强指向去指向对方，这样导致两个对象在内存中无法释放（详情请参考第3章第3节第8题）。

	weak 和 unowned 的使用场景有如下差别：

	当访问对象时该对象可能已经被释放了，则用 weak。比如 delegate 的修饰。
	当访问对象确定不可能被释放，则用 unowned。比如 self 的引用。
	实际上为了安全起见，很多公司规定任何时候都使用 weak 去修饰。

#####6. 在Swift和Objective-C的混编项目中，如何在Swift文件中调用Objective-C文件中已经定义的方法？如何在Objective-C文件中调用Swift文件中定义的方法？

	Swift中若要使用Objective-C代码，可以在ProjectName-Bridging-Header.h里添加Objective-C的头文件名称，Swift文件中即可调用相应的Objective-C代码。一般情况Xcode会在Swift项目中第一次创建Objective-C文件时自动创建ProjectName-Bridging-Header.h文件。

	Objective-C中若要调用Swift代码，可以导入Swift生成的头函数ProjectName-Swift.h来实现。

	Swift文件中若要规定固定的方法或属性暴露给Objective-C使用，可以在方法或属性前加上@objc来声明。如果该类是NSObject子类，那么Swift会在非private的方法或属性前自动加上@objc。

#####7. 要给一个UIButton增加一个点击后抖动的效果，该怎样实现?

	实现一个自定义的UIButton类，在其中添加点击抖动效果的方法（shake方法）。扩展性不好

	写一个UIButton或者UIView的拓展（extension），然后在其中增加shake方法。 可读性比较差

	定义一个protocol，然后在协议扩展（protocol extension）中添加shake方法。 解决了复用性、可读性、维护性三个难题

#####8. 试比较Swift和Objective-C中的初始化方法（init）有什么异同？
	一言以蔽之，Swift中的初始化方法更加严格和准确。

	Objective-C中，初始化方法无法保证所有成员变量都完成初始化；编译器对属性设置并无警告，但是实际操作中会出现初始化不完全的问题；初始化方法与普通方法并无实际差别，可以多次调用。
	Swift中，初始化方法必须保证所有optional的成员变量都完成初始化。同时新增convenience和required两个修饰初始化方法的关键词。convenience只是提供一种方便的初始化方法，必须通过调用同一个类中designated初始化方法来完成。required是强制子类重写父类中所修饰的初始化方法。

#####9. 谈谈对Objective-C和Swift 动态特性的理解
	runtime其实就是Objective-C的动态机制。runtime执行的是编译后的代码，这时它可以动态加载对象、添加方法、修改属性、传递信息等等。
	Swift目前被公认为是一门静态语言。它的动态特性都是通过桥接OC来实现。

#####10. 用Swift 将协议（protocol）中的部分方法设计成可选（optional）

	@optional 和 @required 是 Objective-C 中特有的关键字。

	Swift中，默认所有方法在协议中都是必须实现的。而且，协议里方法不可以直接定义 optional。

	- 在协议和方法前都加上 @objc 关键字，然后再在方法前加上 optional 关键字。该方法实际上是把协议转化为Objective-C的方式然后进行可选定义。

	- 用扩展（extension）来规定可选方法。Swift中，协议扩展（protocol extension）可以定义部分方法的默认实现，这样这些方法在实际调用中就是可选实现的了。