##Effective Object-C 笔记

###1.熟悉Objective-c

####1.了解OC的起源
- Objective-c是一门动态语言。采用`消息结构`而不是`函数结构`。区别在于运行时所应执行的代码完全由运行环境来决定，而不是由编译器决定。

- 函数结构会在编译器根据`虚方法表`查出应该执行那个函数实体。而`消息结构`在编译器并不关心接收对象的类型，也不关心消息发送后具体执行什么方法，而是在运行时才去查找，实现消息的`动态绑定`。所以，oc是一门动态语言。

-运行时的动态性重要工作由`运行时组件（Runtime Component）`完成。OC面向对象特性所需的全部数据结构及函数都在运行期组件里。本质上它是一种与开发者代码相链接的`动态库`，当运行时组件更新是，程勋的性能也能立马提升，不需要再次编译。

- 对象分配的内存中分配在堆中。堆上的内存需要直接管理，栈上的内存会在栈帧弹出是自动清理。

- OC把堆得内存管理抽象出来了。不需要用malloc及free来分配或释放对象所占用的内存。运行期环境把这套内存管理机制抽象成为`引用计数`。

-与创建结构体而言，对象创建需要额外开销。

####2.多用字面量语法，少用与之等价的方法

- 字面量语法实际上是一个“语法糖”，其效果等效于先创建一个数组，然后把方括号内的所有对象都加到这个数组中来。

-字面量语法代码更简洁易懂。同时对于加入的nil对象会抛出异常，也更加安全。等效的方法会过滤掉掉nil对象，在遇到第一个nil对象时添加结束，会导致后面非nil对象的添加失败。

```objective-c
id object1 = /* ... */
id object2 = /* ... */ //nil object
id object3 = /* ... */

//实际只有object1
NSArray *array1 = [NSArray arrayWithObjects:object1, object2, object3, nil];

NSArray *array2 = @[object1, object2, object3];
```
####3.多用常量，少用#define

- 使用#define定义的常量没有类型信息。如果有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。

- static仅在声明的编译单元内可见（.m文件）。加入声明常量是没用static，编译器会为它创建一个`外部符号`。此时，如果另一个编译单元中声明了同名变量，便会抛出error。

- 如有一个常量同时声明为static和const，编译器根本不会创建符号，而是像#define一样执行查找替换，。不过这样定义的常量带有类型信息。

- extern声明的常量放在`全局符号表`中，其它编译单元也可以使用。

- 常量命名规则：常量使用局限于某个编译单元，则前面加字母k；若常量在类之外可见，则通常以类名为前缀。

####4.枚举

- 多个枚举选项之间可以组合，则可以将各选项值定义为2的幂，以便通过按位或操作将其组合。

- 可以使用NS_ENUM与NS_OPTIONS宏来定义枚举类型。

###2.对象、消息、运行期

####1.属性

- OC将实例变量当做一种存储偏移量所用的特殊变量，交由类对象保管。偏移量会在运行期查找。这样，无论何时访问实例变量，总能使用正确的偏移量。甚至可以在运行期向类中添加实例变量。

- @synthesize语法指定实例变量的名字。

- @dynamic会告诉编译器，不要自动创建属性的存取方法，由开发者自己生成。编译器访问属性是，即使编译器没有定义存取方法，也不会报错，它会在运行期去寻找。

#####属性特质
- 若是自己定义存取方法，那么就应该遵守与属性特质相同的特性。

######原子性

-  nonatimic和atomic。atomic会通过同步锁来保证其操作的原子性。

- 但在iOS中所有属性都声明会nonatomic，因为同步锁的开销比较大，会导致性能问题。就算是原子性也不能保证线程安全，还需要更深层的锁定机制才行。（一个线程多次访问某个属性过程中可能有别的线程修改这个属性值。）

######读写权限

- readwrite，会生成getter/setter方法

- readonly，只拥有获取方法，可以h文件声明readonly，m文件声明为readwrite。

######内存管理语义

- assign，只会执行针对`纯量类型`的简单赋值操作。

- strong，拥有关系。设置新值时，先保留新值，释放旧值，然后将新值设置上去。

- weak，非拥有关系。设置方法既不保留新值，也不释放旧值。当属性所指的对象招到摧毁时，属性值也会被设置成nil。

- unsafe_unretained，非拥有关系，与weak语言类似，只是所指对象呗摧毁后，属性值不会自动清空。

- copy，拷贝新值，释放旧值，设置新值。防止可变对象在不知情下被修改。

#####属性访问

- 在ARC下直接访问一个声明为copy的属性，那么不会拷贝该属性，只会保留新值并释放旧值。

- 直接访问实例变量，不会触发`键值观察（KVO）`。

- 是写实例变量是采用其设置方法来做，读取时则直接访问。技能提高读取操作的速度，又能控制对实例的写入。

######注意点

- 初始化方法总是应该直接访问实例变量，因为子类可能`覆写`设置方法。

- dealloc方法中应该直接通过实例变量来读写数据。因为读写方法中可能会增加引用计数，导致对象生命周期延长得不到释放。

####2.对象等同性

- ==操作符比较出来的结果未必是我们想要的，因为该操作比较的事两个指针本身，而不是所指的对象。

- 如果`isEqual:`方法判定两个对象相等，那么其hash方法也必需返回同一个hash值。但是，hash值相同，`isEqual:`方法未必会认为两者相等。

- 编写hash方法时，应该使用计算速度快而且哈希码碰撞率低的算法。

####类簇

- `类簇`是一种很有用的模式，可以隐藏`抽象基类`的实现细节。工厂模式是创建类簇的方法之一。

- 类簇模式可以把实现细节隐藏在一套公共接口后面。

####关联对象

- 可以给对象关联许多其他对象，这些对象通过'键'来区分。存储对象值得时候，可以指明存储策略，用以维护相关的内存管理语义。

- 只有在其它做法不可行时才会应用关联对象，因为由此导致的bug是很查找的。

######关联对象和字典的区别：

- 关联对象的键是不透明的指针。
- 如果在两个键上调用isEqual：返回YES，那么NSDictionary就认为二者相等。
- 若想令关联对象相等，则二者键必须是完全相同的指针才行。鉴于此，设置关联对象的键一般采用全局静态变量。

####3.objc_msgSend的作用

#####各消息发送函数

- objc_msgSend: 一般情况下的消息发送函数。

一些边界情况下函数调用：

- objc_msgSend_stret: 如果待发送的消息要返回结构体，那么可交于此函数处理。

- objc_msgSend_fpret: 如果消息返回的事浮点数，可交由此函数处理。

- objc_msgSendSuper: 给超类发消息，例如[super message:parameter],那么就交由此函数处理。

#####动态消息派发流程

- 1.查看接受者所属的类的方法列表，如果找到与选择器名称相符的方法，就跳至实现方法。
- 2.若找不到，泽沿着继承体系继续向上查找，等找到合适的方法会就跳转。
- 3.如果最终还是没有找到合适的方法，就执行`消息转发`操作。

####4.消息转发机制

- 消息转发机制是在其接受者本身和继承体系方法列表中未匹配到合适方法体的情况下被触发调用的。

#####消息转发分为三步：

- 1.动态方法解析：先征询接受者所属的类，是否能动态添加方法，以处理当前选择子。
	
	`resolveInstanceMethod:`
	
- 2.请求接受者查看是否是否有其它对象能处理选择子，有则运行期系统会把消息转发给那个对象。

	`forwardingTargetForSelector:`

- 3.没有则启动完整消息转发机制，把与消息有关信息全部组装在NSInvocation中，通过修改invocation的信息体，尝试转发处理。

	`forwardInvocation:`
	
######note

- 在完整消息转发机制中，若发现调用操作不因由奔雷处理，需调用超类的同名方法。这样，继承体系中每个方法都会有机会处理此调用请求，直至NSObjet。如果最后调用了NSObject类的方法，那么该方法还会继而调用“doesNotRecongnizeSelector：”以抛出异常，表面该选择子未能处理。


####5.方法调试（Method swizzling）

- 类的方法列表会把选择子的名称映射到相关的方法之上，这些方法实现均已IMP的函数指针的形式来表示。

- method swizzling主要就是通过操作这张方法列表来达到目的。

- 开发者可以为那些“完全不知道其具体实现的”黑盒方法增加日志记录功能，方面进行调试。

####6.类对象

- 每个OC对象实例都是指向某块内存数据的指针。

- 通用的对象类型id，其本身已经是指针了。

- 类对象所属的类型（也就是isa指针所指向的类型）是另一个类，叫做`元类`。用来表述类对象本身所具备的元数据。每个类只有一个类对象，每个类对象只有一个与之相关的元类。

- isMemberOfClass: 能判断是否为某个类的实例。isKindOfClass: 能判断出对象是否是某个类或其派生类的实例。

- 使用==操作符来判断类对象是否相同，之所以不用isEqual：，是因为类对象是单例（Singleton），在应用程序范围内，每个类的Class只有一个实例。

###3.接口与API设计

####1.尽量使用不可变对象
- 对于在h文件中设置为readOnly的属性，仍然能通过KVC（键值编码）技术设置该属性值。但得自己应对可能出现的问题。

- 若某属性尽可用于对象内部修改，则在“class-continuation分类”中将其由readOnly属性扩展为readwrites属性。

- 不要把可变的collection作为属性公开，而应提供相关方法，以此修改对象中的可变collection。

####2.NSCopying协议

- 类需要支持拷贝操作，则需实现NSCopying协议，该协议只有一个方法：
	```
	-(id)copyWithZone:(NSZone*)zone
	```
- 实例变量访问内部实力变量，使用->语法。 object->property

#####深拷贝和浅拷贝

- 深拷贝指在拷贝对象自身时，将其底层数据也一并复制过去。
- 浅拷贝只拷贝容器本身，不复制其中数据。
- 浅拷贝之后的内容与原始内容均指向相同对象。而深拷贝之后的内容所指向的对象是原始内容相关对象的拷贝。

######主要原因：

容器内的对象未必都能拷贝，而且调用者也未必想在拷贝容器时一并拷贝其中的每个对象。

###4.协议与分类

####1.委托
- 存放委托对象的属性那么设置成weak，要么设置成unsafe_unretained。如果需要在相关对象销毁时自动清空，则选择weak。否则选择后者。

- 再给已经释放的委托对象发送消息是也能照常运行，因为给nil对象发送消息将使if语句的职成为false。

```
	if ([_delegate respondsToSelector:Selector]){
		[_delegate selector];
	}
```

- 在调用delegate中的方法时，总是应该吧发起委托的实例也一并传入方法中。
- 委托模式是信息流向代理者，数据源模式是信息流向委托者。
- 通常使用`位段`数据结构来缓存delegate是否能响应某个协议方法，以优化程序效率。一般针对频繁通过数据源协议从数据源获取多份相互独立的数据。

####2.通过协议提供匿名对象

- 在字典中，键的标准内存管理语义是“设置时拷贝”，而值得语义是“设置时保留”。只要遵守NSCopying协议的对象都可以作为键。
- 协议在某种程度上提供匿名类型。具体的对象类型可以淡化成遵守某个协议的id类型，协议里规定了对象所应实现的方法。
- 如果 具体类型不重要，重要的事对象能响应特定方法，那么可以使用匿名对象来表示。

###5.内存管理

####1.引用计数

- 内存管理分为MRC和ARC。MRC需要手动管理对象的保留和释放。ARC会自动为对象添加retain和release来管理内存。因此主动添加与引用计数相关的方法都会无法编译。但在ARC中c对象还是需要自己手动释放，否则会内存泄漏。

- 调用autorelease的对象会被放入`自动释放池（autorelease pool）`，待稍后清理pool时再递减保留计数。这样有时用retainCount获取的结果就会不准确。

- autorelease可以用来延迟对象的声明周期。

- 除非是自己创建的自动释放池，否则自动释放的时机指的就是当前线程的下一次事件循环。

- 因此，绝不应该说保留计数一定是某个值，只能说所执行的操作是递增了该计数还是递减了该计数。

######引用计数工作原理

	引用计数架构下，每个对象会有个计数器，用以表示有多少个对象想此对象继续存活下去。当计数归零时，对象就被回收，系统会将其占用的内存标记为“可重用”。

	回收的内存在未重新覆盖时，其中的某些对象还是可以访问到继续使用。所以引用对象的指针要置为nil，否则就会成为野指针。这种过早释放导致的bug很难调试。
	
- 应用程序在器生命周期创建的许多对象之间相互联系，形成一个`对象引用树`，在MAC中根对象是NSApplication，iOS中是UIApplication。两者都是应用程序创建时的单例。

######属性的存取方法

- 对于strong属性的设置，必须是先保留新值，释放旧值，然后设置新值，顺序很重要。如果两个值指向同一对象，释放旧值操作可能令这个对象被永久回收，后续的retain操作也无法令已经回收的对象复生，于是实例变量就变成了悬挂指针。

####2.ARC简化引用计数

- 原理：Clang编译器有一个`静态分析器`，用于指明程序里引用计数出现问题的地方。ARC中会据此加入适当的保留或释放的操作以避免问题。

- 在ARC中，引用计数实际还是要执行的，只不过保留与释放操作现在是由ARC自动添加。因此，手动添加会干扰其工作，导致无法编译。

- ARC并不是添加oc的普通消息转发语句，而是直接调用底层c语言版本。因为保留和释放操作需要频繁执行，直接使用底层函数合一节省很多CPU周期。

######内存管理语义

```
 __strong : 默认语义，保存该值。
 __unsafe_unretained : 不保留此值，这么做可能不安全。下次调用该值时，其对象可能已经呗回收了。
 __weak : 不保留此值，但可以安全使用。对象回收时，该值也会自动清空。
 __autoreleasing : 把对象按“引用传递”给方法时，使用这个特殊的修饰符。此值在方法返回时自动释放。
```

- block会自动保留其所捕获的全部对象，而如果其中有某个对象又保留了块本身，便会导致`引用环`。

- 对于非Objective-C的对象，比如CoreFoundation中的对象或是由malloc（）分配在堆中的内存，那么仍然需要手动释放。

####3.dealloc

- 不要主动调动dealloc，因为程序库会以开发者无法察觉的方式操作对象，从而使对象回收的真正时机和预期的不同。

- 在dealloc方法中，应该做的事就是释放对其它对象的引用，并取消原来订阅的`键值观察（KVO）`或`NSNotificationCenter`等通知，不要做其它事。

- 在dealloc 中不要随便调用其它方法，也不要调用属性的存取方法，因为这些方法中可能会产生一些无法再回收阶段无法安全执行的操作。
	调用dealloc的那个线程会执行最后的释放操作，如果调用别的方法需要进入特殊进程，当前的进程可能无法满足它而导致不安全。
	
####4.异常安全与内存管理

- 捕获异常是，一定要注意清理干净try块内的对象。

- 默认情况下，ARC不生成安全处理异常的清理代码。开启编译器标志后，可以生成这种代码，不过会导致应用程序变大，而且会降低运行效率。

- 一般抛出异常程序也就总结了，内存也会被系统回收，所以抛出异常后的内存泄漏一般不用处理。

####5.将某些引用设为weak，可避免出现`保留环`。

####6.自动释放池

- 系统会自动创建一些线程，比如主线程或是“大中枢派发GCD”机制中的线程，这些线程都有自动释放池，每次执行"事件循环"时，就会将其清空。

- 一般不需要自己创建自动释放池，通常只有一个地方需要创建自动释放池，那就是main函数里，我们用自动释放池来包裹应用程序的主入口点。当应用程序结束时，系统会吧程序所占的全部内存都释放掉。

- 通过嵌套自动释放池，可以借此控制应用程序的内存峰值。

- @autoreleasepool 是轻量级的，每个释放池均有其范围，可以避免无意间使用了已经被系统所回收的对象。

####7."僵尸对象"调试内存管理问题

- 向已经回收的对象发送消息是不安全的，完全取决于对象所占用的对象有没被其它内容所覆写，并且新的对象能响应消息的可能性微乎其微。

- `僵尸对象`（Zombie Object）是xcode的一项调试功能，开启后运行期系统会把所有已经回收的实例转化为特殊的“僵尸对象”，这种对象的核心内存无法重用，因此不可能遭到覆写。

- 运行期系统如果发现NSZombieEnabled环境变量已设置，就会swizzle dealloc方法，对象所占用的内存将不会释放，内存不可复用，该类也变成_NSZombie_OriginalClass了。

- 系统会修改对象的isa指针指向特殊的僵尸类。僵尸类能响应所有的选择子，响应方式：打印一条包含消息内容及其接受者的消息，然后终止应用程序。

###6.块与大中枢派发

`当前多线程的核心就是块（block）和大中枢派发（Grand Central Dispatch）。`

`GCD是一种与块有关的技术，它提供了对线程的抽象，而这种抽象则机遇“派发队列”`。

####1.block
-	块其实就是个值，而且自有其相关类型。
- 块的强大之处：声明它的范围里，所有变量都可以被其所捕获。
- 块本身也和其它对象一样，有引用计数。

- 块其实就是一种代替函数指针的语法结构，原理使用函数指针时，需要用“不透明的void指针”来传递状态。改用块可以吧原来用标准C语言特性编写的代码封装成简明且易用的接口。

- 块会把它所捕获的变量都拷贝一份，拷贝的并不是对象本身，而是指向这些对象的指针变量。（浅拷贝）

#####块分为全局块、堆块、栈块

- 区分点意识block在创建的时候，一是在复制给其它变量的时候。ARC和MRC下也略有不同。

#######1.在创建的时候

	1.1. 如果一个block中引用了全局变量，或者没有引用任何外部变量(属性、实例变量、局部变量)，那么该block为全局块。
	1.2. 其它引用情况(局部变量，实例变量，属性)为栈块

#######2.在将block对象赋值给其它对象^(oBlock)()的时候(ARC):

	2.1. 如果block是栈块，那么oBlock变成堆块(因为Clang编译器帮我们往block发送了copy消息)。
	2.2. 如果block是全局块，那么oBlock也是全局块，如果block是堆块，那么oBlock也是堆块。

#######3.在将block对象赋值给其它对象^(oBlock)()的时候(MRC):

	3.1. block是什么，oBlock便是什么。
	
####2.typedef

- typedef可以为类型定义别名。
- 可以为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，那么只需要修改相应typedef中的块签名即可，无需改动其它typedef。

####3.保留环

- 要想打破保留环，最好就是在调用block之后将对block持有的指针置空。

####4.多用派发队列。少用同步锁

#####1.同步锁

	1.同步块（synchronization block）
	@synchronization(self) {
		//safe
	}
	
	2.NSLock
	_lock = [[NSLock alloc]init];
	
	[_lock lock];
	//safe
	[_lock unlock];
	
- 极端情况下，同步块会产生死锁。
- 同步锁虽然能提供某种程度上的线程安全，但不是绝对安全。

#####2.同步队列

- 可以采用`串行同步队列`代替同步块或锁对象。将读取操作及写入操作放入同一队列中，即可保证数据同步。
- 执行一部派发时，需要拷贝块。若拷贝的时间成本大于执行该块的时间，则异步是不必要的。

```
串行队列 
_syncQueue = dispatch_queue_create("com.xxxx.xxx", NULL)

并行队列
_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PROORITY_DEFAULT, 0)

同步异步
dispatch_sync()
dispatch_async()

栅栏（barrier）异步/同步	
dispatch_barrier_async()
dispatch_barrier_sync()
```
- 对队列中，栅栏块必须单独执行，不能与其它块并行。这只对并发队列有意义。
- 并发队列如果发现接下来执行的是个栅栏块，那么就会一直等待当前所有并发块都执行结束，然后来单独执行这个栅栏块。栅栏块结束后，再按正常方式继续向下进行处理。
- 将同步和异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。

####5.perfromSelector系列

- perfromSelector系列方法在内存管理上面容易有疏忽。

```
	perfrom系列经常用在运行时动态调用方法。由于编译器不知道将要调用的方法子是什么，也不知道是否有返回值。这样ARC便无法采用内存管理的规则来进行判断，ARC采用了比较谨慎的做法，就是不添加释放操作。
```

- 该系列方法只能返回id对象，传入参数也有限制，使用上有局限性。

####6.GCD及操作队列的使用时机

- 解决多线程与任务管理问题上，派发队列并不是唯一方案。

- 操作队列在底层是用GCD来实现的。
- GCD是纯C的API，任务用块表示，是轻量级数据结构。而NSOperation是OC对象，操作则是重量级的OC对象。有时候采用对象带来的开销微乎其微，使用完整对象反而更好。

#####1.NSOperation使用的好处

- 可以取消操作。调用NSOperation的cancel方法，会设置对象内的标志位，用以表示该任务不用执行。但是已启动的任务是无法取消的。GCD任务一但安排好之后就无法控制了。
	
- 指定操作间的依赖关系。GCD可以通过group组来进行依赖控制，但比较有限。

- 通过键值观测机制监控NSOperation对象的属性。

- 指定具体操作的优先级。GCD只能整个队列的优先级，不能具体到块。

- 可以重用NSoperation对象。

####7.通过Dispatch Group机制，根据系统资源状况来执行任务

- 将将要并发执行的多个惹怒合为一个组，调用者可以等待这组任务执行完成，也可以在结束后的回到函数之后继续往下执行。

- 可以把在不同优先级线程上的任务归于同一个dispatch group，并在执行完毕时获得通知。

- 如果把所有任务放于一个串行队列中，那么这个dispatch group就毫无意义了。我们可以在执行完全部任务之后再提交一个任务，达到通过notify函数等待dispatch group执行完毕然后再回调块是等价的。

######dispatch_apply

`dispatch_apply(size_t iterations, dispatch_queue_t queue, void(^block)(size_t))`

该函数会反复执行一定的次数。

- 可代替dispatch group，但会持续阻塞，直到所有任务都执行完毕为止。加入把块派给了当前队列或高于当前队列的串行队列，将会产生死锁。

- dispatch_apply如果采用并发队列，那么系统就可以根据资源情况来并行执行这些块了。

####8.其它

- dispatch_once更高效，他没有使用重量级的同步机制。此函数采用"原子访问"来查询标记，以判断其所对应的代码已经执行过。

- dispatch_get_current_queue函数的行为往往与开发者所预期的不同。函数已经废弃，只做调试之用。

- 派发队列是按照层级来组织的，所以无法单用某个队列来描诉“当前队列”这一概念。因为层级之间队列属性关系会影响当前队列的某些行为。

###7.系统框架

####1.遍历
- 遍历collection有四种方式。最基本得失for循环，其次是NSEnumerator遍历法及快速遍历法，最新、最先进的方式是“块枚举法”。
- 通过NSEnumerationREverse进行反向遍历，只对数组和set等有顺序的collection时才有效。
- 块枚举法本身就能通过GCD来并发执行遍历操作，无需另写代码。
- 若提前知道遍历的collection含有何种类型对象，则应该修改块签名。

####2.无缝桥接 __bridge
- 通过无缝桥接，可以让Foundation框架中的OC对象和CoreFoundation中的C语言数据结构之间来回切换。
- CoreFoundation层面创建collection时，可以指定回调函数，这些函数指明collection应该如何处理其中元素。可以运用无缝桥接技术，将其转换成OC对象进行处理。

####3.NSTimer

- 计时器要和“运行循环（run loop）”相关联，运行循环到时会触发任务。只有将计时器放入运行循环中，它才能正常执行。

- 计时器会保留其目标对象，等到自身释放时才会释放对象。容易导致循环引用，可以通过block块打破保留环，这样block中的引用可以用weak来打破。

####4.NSCache

- 只有那种“计算起来很费力的”数据，才值得放入缓存。

######NSCache的优点：

- NSCache可以在系统资源紧张时，自动删减缓存。此外，NSCache会先行删除“最久未使用的”对象。

- NSCache并不会拷贝键，而是保留。因为很多时候键都是由不支持拷贝的对象来充当的。

- NSCache是线程安全的，开发者可以不编写枷加锁代码的前提下，多线程访问NSCache。


######删减缓存的时机
- 有两个尺度可以把控：意识对象`总数`，一是对象的`总开销`。
- 另一种是系统资源紧张时，NSCache会自动删减。

- 尺度把控只能说明可能会删减某个对象，并不意味着一定会删减这个对象。具体顺序要看具体实现。因此，通过调整尺度来迫使缓存优先删除某对象是不合理的。

- 选择的`开销值`要获取，如果开销过大，比如需要访问磁盘或者数据库之类的就得不偿失了。

#######NSPurgeableData

- 当对象资源紧张时，可以把保存NSPurgeable对象的那块对象是释放掉，同时也会自动从缓存中移除。
- 访问某个NSPurgeble对象时，先调用beginContentAccess方法，告诉它现在还不能丢弃自己占用的内存。用完之后，调用endContentAccess方法，告诉它可以在适当的时候释放掉自己。
- 创建好NSPurgeable对象之后，其`purge引用计数`会大于1，所以无需调用beginContentAccess了，但必须后面调用endContentAccess，将多出的1抵消掉。

####5.initialize与+load

#####+ (void)load

- 对于加入运行期的类或分类，必定会调用该方法，且只调用一次。

- 分类和所属的类都定义了load方法，会优先调用类里的，然后调用分类。

- 因为无法判断各个类在运行期的调用顺序，所以在load中调用其它类是不安全的。

- 无复覆写机制。某个类没实现load方法，那么不管其各级超类是否实现此方法，系统都不会调用。

- load方法尽量精简，不要在里面等待锁，也不要调用可能会加锁的方法。因为整个应用程序在执行load的时候都会阻塞。它的真正用途仅在于调试。

#####+（void)initialize

- 该方法会在程序首次使用该类之前调用，且自调用一次。它是由运行期系统调用的，不能手动调用。

- 运行期系统调用该方法时处于正常状态，在方法里面可以调用任意类的任意方法。

- 只有操作initialize的那个线程可以操作类或类实例，其它线程要先阻塞知道initialize方法执行完。

- 有覆写机制。如果某个类没有实现它，而其超类实现了，就会调用超类中的方法。

- 方法尽量精简，不要在里面执行好使太久或加锁的任务。

- initialize方法只应该用来设置一些自己的内部数据。即使是类自己的方法也不要调用，因为无法确定调用的方法会执行什么。
- 如果某个全局状态无法在编译期初始化，则可以放在initialize里来做。




